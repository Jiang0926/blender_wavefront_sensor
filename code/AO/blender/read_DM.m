%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Loads the data generated by blender in the
% files DM*.m and process/show them
%
%   DM*.m contains the data measured of a AO 
%   calibration procedure.
%   In blender, the deformble mirror have its
%   actuators poked one by one each one
%   generating a file DMij.m
%   Each file has the light hits (x and y)
%   already grouped in a 12 x 12 detector grid
%   the measured centers cx and cy (also 12x12)
%   and the calibrated centers (no atmosfere)
%   calCx and calCy.
%
%   After reading this data, we assemble the 
%   command matrix ([dx; dy] = M*[dm11; dm12; ...])
%
%   after inverting the command matrix, we 
%   perform some reconstructions as examples.
%
%   OBS.:
%
%     Copy files from /tmp/DM*.m
%
%
%  Steps to use the DM to correct for objects in front of the WFS:
%
%   1 - In blender, calibrate the WFS wi no object in front of it.
%   2 - Put the object you want to the DM to correct to in front of the WFS
%   3 - Click compute (this will generate a file current.m that have the
%   WFS measurement 
%   4 - In Matlab, run this file with mode='current' (see switch bellow).
%   This will make this script to compute the DM commands for the
%   deformation blender sensed and will generate a file cmd which contains
%   the mirror commands
%   5 - Back in blender load DM commands and compute again. 
%   6 - Be amazed on how a 6x6 deformable mirror could (at least a little
%   bit) correct for an infinite degree of freedon continuous "lens" sensed
%   by small ~ 12x12 wavefront sensor.
%   7 - Cry because you have noone to share this happy moment hehehehehehehe

clear();
clc();
close('all');
v = cell(6,6);

eval('!mv /tmp/*.m ./');

% command matrix
M = [];

F1 = figure();
POS1 = get(F1,'Position');
set(F1,'Position',[POS1(3)+50 POS1(4)+160 POS1(3) POS1(4)]);
POS1 = get(F1,'Position');


% read all 36 data files each corresponding to the poking of one actuator
% in the deformable mirror
for i=1:6
    for j=1:6
        
        eval(sprintf('DM%d%d',i-1,j-1));
        v{i,j}.x = x; 
        v{i,j}.y = y; 
        v{i,j}.cx = cx; 
        v{i,j}.cy = cy; 
        v{i,j}.calCx = calCx; 
        v{i,j}.calCy = calCy; 

        % plot the wavefront fases
        axes('position',[2*(j-1)/12 (i-1)/6 1/12 1/6])
        quiver(cy,cx,cy-calCy, cx-calCx)
        axis('equal');
        axis('square');
        axis('off');
        
        % plot wavefront intensity
        axes('position',[2*(j-1)/12+1/12 (i-1)/6  0.95/12 0.95/6])
        I = sqrt((cx-calCx).^2 + (cy-calCy).^2);
        imagesc(I(end:-1:1,:));
        axis('square');
        axis('off');
        
        drawnow();
        
        % assemble the iteraction matrix.
        % As each file is the data from ONE actuator, 
        % the vetor [dm11; dm12; ...] is [0 ... 0 1 0 ... 0]
        % and the vector [dx; dy] is the measurement itself [cx-calCx;
        % cy-calCy] hence the column in the matrix M will be [cx-calCx;
        % cy-calCy] itself.
        M = [M [(cx(:)-calCx(:)); (cy(:)-calCy(:))]];
        
    end
end


% load last computed geometry and call it 'current'
eval('current');
cur_x = x; 
cur_y = y; 
cur_cx = cx; 
cur_cy = cy; 
cur_calCx = calCx; 
cur_calCy = calCy; 

% compute the vector field for current geometry
cur_clx = cx-calCx;
cur_cly = cy-calCy;



F2 = figure();
POS2 = get(F2,'Position');
set(F2,'Position',POS1+[0 -POS1(4)-80 POS2(3) 0]);
axes('position',[0.05 0.05 0.9 0.9]);
imagesc(M');
axis('off');
title('Interaction Matrix');

maskDet = 1+0./(abs(cx)>0);

% SVD of the command matrix (to see the modes)
[U, S, V] = svd(M);

% plot the modes of the command matrix eigevectors of M reshaped.
F3 = figure();
POS3 = get(F3,'Position');
set(F3,'Position',POS1+[POS1(3)+10 0 0 0]);
for i=1:6
    for j=1:6
        subplot(6,6,i+(j-1)*6);
        imagesc(reshape(V(:,i+(j-1)*6),6,6));
        axis('square')
        axis('off');
    end
end


% invert M either using the eigenvalues or pseudoinverse. Although they to
% the same result in the default case, using SVM gives us the oportunity to
% ignore small eiganvalues and make a filtered versoin fo the inversion.

%iS = [inv(S(:,1:36)) zeros(36,288-36)];
%C = U*iS*V'
C = pinv(M');



% several reconstructions examples
%
%  cxl and cyl are the vetorized desired geometry
%  dxl and dyl are the reshaped version (for ploting)
%

% in case we need to generate some geometry
[X, Y] = meshgrid(linspace(-1,1,12),linspace(-1,1,12));

disp(char([10 10]));
fprintf(['To compute the DM commands for an object that you put in ',char(10),...
         'the system in blender, calibrate the system without object,', char(10),...
         'put the object you want in front the WFS and click compute.', char(10),...
         'This will generate current.m file that has the WFS readings', char(10),...
         'for the object'],'s');
disp(char([10 10]));

mode = 'current';
%mode = 'Z Astisgmatism';
%mode = 'Z coma';

switch mode 

    case 'current'
        % compute command to undo the current geometry. To perform the AO
        % correction.
        %
        cxl = -cur_clx;
        cyl = -cur_cly;
        dxl = reshape(cxl,12,12);
        dyl = reshape(cyl,12,12);    
    
    case 'self'
        % Just use two of the poked geometries as reference (first and
        % last) this obviously will work perfectly, for the command will
        % always be [1 0 0 0 0 ... 0 1]
        %
        cxl = M(1:144,1) + M(1:144,end);%zeros(12);
        cyl = M(145:end,1) + M(145:end,end);%ones(12);
        dxl = reshape(cxl,12,12);
        dyl = reshape(cyl,12,12);

    case 'tiptilt'
        % Tip and tilt. Flat geometry. This is very very hard for our 6x6
        % imprecise DM
        %
        cxl = ones(12);
        cyl = ones(12);
        dxl = reshape(cxl,12,12);
        dyl = reshape(cyl,12,12);
 
        
    case 'gaussian'
        % Gaussian amplitude profile. Fase is make by gradienting the
        % gaussian
        %
        tmp = exp(-8*X.^2 - 8*Y.^2);
        [dyl, dxl] = gradient(tmp);
        cxl = dxl(:);
        cyl = dyl(:);
        
    case 'eigenmodes'
        % Just use two of the eigenmodes as reference (first and last) this
        % obviously will work perfectly because the eigenmode is a
        % combination (by construction) of the collumn space of the command
        % matrix
        %
        tmp = M*V(:,1);
        cxl = tmp(1:144,1);
        cyl = tmp(145:end,1);
        dxl = reshape(cxl,12,12);
        dyl = reshape(cyl,12,12);

    case 'Z Astisgmatism'
        % Try to model Zernikes' astigmatism mode
        %
        o = atan2(Y,X);
        p = sqrt(X.^2+Y.^2);
        tmp = p.^2.*cos(2*o);
        [dyl, dxl] = gradient(tmp);
        cxl = dxl(:);
        cyl = dyl(:);

    case 'Z coma'
        % Try to model Zernikes' coma mode
        %
        o = atan2(Y,X);
        p = sqrt(X.^2+Y.^2);
        tmp = (3*p.^2-2).*p.*cos(2*o);
        [dyl, dxl] = gradient(tmp);
        cxl = dxl(:);
        cyl = dyl(:);
        
    case 'Z spherical'
        % Try to model Zernikes' spherical aberraion mode
        %
        o = atan2(Y,X);
        p = sqrt(X.^2+Y.^2);
        tmp = 6*p.^4-6*p.^2+1;
        [dyl, dxl] = gradient(tmp);
        cxl = dxl(:);
        cyl = dyl(:);
        
        
end




cmd = C'*[cxl(:); cyl(:)];

% save mirror commands
%
% Saves que mirror commands to be loaded by blender in order to correct fro
% the deformation present in the 'mode' variable.
%
% In order to to use the deformation present in the blender screene, set
% mode varaible to 'current'
fid=fopen('/tmp/cmd','wt');
fprintf(fid,'%.8f ',cmd);
fclose(fid);
fprintf(...
['******************************************************************', char(10), ...
 '* /tmp/cmd generated. You can click "Load DM Commands in blender *', char(10), ...
 '******************************************************************', char(10) ...
 ]);


tmp = M*cmd;
dx = reshape(tmp(1:144,1), 12, 12);
dy = reshape(tmp(145:end,1), 12, 12);

F4 = figure();
POS4 = get(F4,'Position');
set(F4,'Position',POS1+[-POS1(3)-10 -POS1(4)-60 0 POS1(4)]);

subplot(2,1,1)
hold('on');

title(sprintf('Reconstruction shape:\n %s',mode));
quiver(cx, cy, dx.*maskDet, dy.*maskDet, 'color', 'b')
quiver(cx, cy, dxl.*maskDet, dyl.*maskDet, 'color', 'r')
axis('square')

subplot(2,1,2)
imagesc(reshape(cmd,6,6));
title(sprintf('Commands for\n %s',mode));
axis('square')
